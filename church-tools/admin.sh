#!/bin/sh
#
# Script to do administrative tasks for the church site
set -e
set -x

cmd=$1

projdir="`dirname $0`"
projdir="`cd "$projdir/.."; pwd`"

# Don't use this password if your MySQL server is on the public internet
sqlrootpw="q9z7a1"

# Ubuntu packages we need to install and uninstall in order to
# reproduce everything cleanly.
pkgs="mysql-client mysql-server drush php5-gd apache2 libapache2-mod-php5 ssmtp"

do_deps() {
    # FIXME: move secrets to ~/secrets.dat rathern than hardcoding them
    # or asking user to edit random files
    # And use debconf to suppress that password prompt; see
    # http://askubuntu.com/questions/79257/how-do-i-install-mysql-without-a-password-prompt

    echo "When prompted, enter $sqlrootpw for the sql root password."
    sleep 4
    set -x
    sudo apt-get install -y $pkgs

    # Configure ssmtp
    sudo tee /etc/ssmtp/ssmtp.conf <<_EOF_
root=postmaster
UseSTARTTLS=YES
hostname=`hostname`
# Edit the following lines
mailhub=mail.church.org
RewriteDomain=church.org
AuthUser=you@church.org
AuthPass=XXXXXXXX
_EOF_

    echo "Adding $LOGNAME to mail group.  Won't take effect until next login."
    sudo useradd -G mail $LOGNAME

    echo "Template created in /etc/ssmtp/ssmtp.conf.  Please edit it,"
    echo "log out and back in, and make sure you can send mail using /usr/sbin/sendmail."
}

do_install() {
    cd "$projdir"

    if test -f sites/default/settings.php
    then
        echo "Already installed, aborting"
        exit 1
    fi

    # Note: older versions of drush didn't need the 'standard' word
    drush si standard --site-name=Church --db-url=mysql://root:$sqlrootpw@localhost/drupal --account-name=drupal --account-pass=drupal

    # FIXME: This is insecure, but required to pass the status report tests
    chmod 777 sites/default/files

    # Support both Ubuntu 12.04 and 14.04?
    wwwdir=/var/www
    if test -d /var/www/html
    then
        wwwdir=/var/www/html
    fi

    sudo mv $wwwdir $wwwdir.bak.$$
    sudo ln -s "$projdir" $wwwdir
    sudo a2enmod rewrite

    # https://drupal.org/getting-started/clean-urls
    sudo tee /etc/apache2/conf-enabled/church.conf > /dev/null <<_EOF_
<Directory /var/www/html/church-tools>
    Options -Indexes +FollowSymLinks
    AllowOverride None
    Order allow,deny
    deny from all
</Directory>
<Directory /var/www/html>
    RewriteEngine on
    RewriteBase /
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteCond %{REQUEST_URI} !=/favicon.ico
    RewriteRule ^ index.php [L]
</Directory>
_EOF_
    sudo service apache2 restart
    # You may also need to set base_url in sites/default/settings.php
}

do_reinstall() {
    cd "$projdir"
    pwd

    if ! test -f sites/default/settings.php
    then
        echo "Not already installed, aborting"
        exit 1
    fi
    mv sites/default/settings.php ~/settings.php.bak

    # Note: older versions of drush didn't need the 'standard' word
    drush si standard --site-name=Church --db-url=mysql://root:$sqlrootpw@localhost/drupal --account-name=drupal --account-pass=drupal || true

    chmod 755 sites/default
    mv ~/settings.php.bak sites/default/settings.php
}

# Some scary stuff follows, but it's all pretty simple
# generating files from a template given the list of
# vocabularies.

# Output migration classes for all vocabularies
generate_classes() {
   cat <<"EOF" > /tmp/template.$$.tmp
# Generated by church-tools/admin.sh, one class per vocabulary
# See https://www.drupal.org/node/1659838
class Church@VMNAME@Migration extends Migration {
  public function __construct($arguments) {
    parent::__construct($arguments);
   $vid = @VID@;
   $vmname = "@VMNAME@";
   $query = Database::getConnection('default', 'for_migration')
          ->select('term_data', 'td')
          ->fields('td', array('tid', 'vid', 'name', 'description', 'weight'))
          ->condition('td.vid', $vid, '=');
   # Mark nonjoinable, since we expect source to be remote
   # That means we need to simulate a join in prepareRow()
   $this->source = new MigrateSourceSQL($query, array(), NULL, array('map_joinable' => FALSE));
   $this->destination = new MigrateDestinationTerm($vmname);
   $this->map = new MigrateSQLMap($this->machineName,
        array(
          'tid' => array(
            'type' => 'int',
            'unsigned' => TRUE,
            'not null' => TRUE,
            'description' => 'Drupal 6 term ID',
            'alias' => 'td',
          )
        ),
        MigrateDestinationTerm::getKeySchema(),
          'for_migration'
   );
   $this->addFieldMapping('name', 'name');
   $this->addFieldMapping('description', 'description');
   $this->addFieldMapping('parent', 'parent')
     ->sourceMigration($this->machineName);
  }

  public function preImport() {
   # Shared among all generated taxonomy migration classes
   global $taxonomy_migration_parentof;
   if (isset($taxonomy_migration_parentof))
     return;

   # Retrieve the hierarchy table so we can decorate rows with it
   $result = Database::getConnection('default', 'for_migration')
      ->query("select * from term_hierarchy where parent != 0");
   if ($result) {
      foreach ($result as $row) {
         $taxonomy_migration_parentof[$row->tid] = $row->parent;
      }
   }
  }

  public function prepareRow($current_row) {
   global $taxonomy_migration_parentof;
   if (parent::prepareRow($current_row) === FALSE) {
     return FALSE;
   }
   $current_row->parent = $taxonomy_migration_parentof[$current_row->tid];
  }
}
EOF

   echo '<?php'
   for vid in `awk '{print $1}' < data/taxonomy/vocabularies.txt`
   do
       vname=`awk -F'\t' '$1 == "'$vid'" {print $2}' < data/taxonomy/vocabularies.txt`
       vmachine_name=`echo $vname | tr -d ' |/'`
       sed "s|@VID@|$vid|;s|@VNAME@|$vname|;s|@VMNAME@|$vmachine_name|" < /tmp/template.$$.tmp
   done
   echo '?>'
   rm /tmp/template.$$.tmp
}

# Output fragment with list of all generated classes, for use in church_migrate_migrate_api()
generate_class_list() {
   cat <<"EOF" > /tmp/template.$$.tmp
            '@VMNAME@' => array(
                'class_name' => 'Church@VMNAME@Migration',
                'group_name' => 'ChurchVocabMigrate'
            ),
EOF
   echo '<?php'
   echo '$generated_array = array('
   for vid in `awk '{print $1}' < data/taxonomy/vocabularies.txt`
   do
       vname=`awk -F'\t' '$1 == "'$vid'" {print $2}' < data/taxonomy/vocabularies.txt`
       vmachine_name=`echo $vname | tr -d ' |/'`
       sed "s|@VID@|$vid|;s|@VNAME@|$vname|;s|@VMNAME@|$vmachine_name|" < /tmp/template.$$.tmp
   done
   echo ");"
   echo "?>"
   rm /tmp/template.$$.tmp
}

generate_vocabulary_list() {
   # fragment for use in church_migrate_enable() to create vocabularies
   cat <<"EOF" > /tmp/template.$$.tmp
            array(
                'name' => '@VNAME@',
                'machine_name' => '@VMNAME@',
            ),
EOF
   echo "<?php"
   echo '$generated_array = array('
   for vid in `awk '{print $1}' < data/taxonomy/vocabularies.txt`
   do
       vname=`awk -F'\t' '$1 == "'$vid'" {print $2}' < data/taxonomy/vocabularies.txt`
       vmachine_name=`echo $vname | tr -d ' |/'`
       sed "s|@VID@|$vid|;s|@VNAME@|$vname|;s|@VMNAME@|$vmachine_name|" < /tmp/template.$$.tmp
   done
   echo ");"
   echo "?>"
   rm /tmp/template.$$.tmp
}

# fragment for use in church_migrate_disable()
generate_deregistrations() {
   cat <<"EOF" > /tmp/template.$$.tmp
       Migration::deregisterMigration('@VMNAME@');
EOF

   echo "<?php"
   for vid in `awk '{print $1}' < data/taxonomy/vocabularies.txt`
   do
       vname=`awk -F'\t' '$1 == "'$vid'" {print $2}' < data/taxonomy/vocabularies.txt`
       vmachine_name=`echo $vname | tr -d ' |/'`
       sed "s|@VID@|$vid|;s|@VNAME@|$vname|;s|@VMNAME@|$vmachine_name|" < /tmp/template.$$.tmp
   done
   echo "?>"
   rm /tmp/template.$$.tmp
}

do_taxgen() {
   # This has to run on old system where drush was in home directory.  Go figure.
   PATH=$PATH:$HOME

   mkdir -p data/taxonomy
   # Get list of vid's
   drush sqlq 'select vid, name from vocabulary;' | sed 1d | sort -n > data/taxonomy/vocabularies.txt

   rm -f data/taxonomy/generated_*.*
   generate_classes > data/taxonomy/generated_taxonomy_migration_classes.inc
   generate_class_list > data/taxonomy/generated_taxonomy_migration_class_list.inc
   generate_vocabulary_list > data/taxonomy/generated_taxonomy_migration_vocabulary_list.inc
   generate_deregistrations > data/taxonomy/generated_taxonomy_migration_deregistrations.inc
}

# Deprecated... use taxgen and normal migration instead
do_taxout() {
   # This has to run on old system where drush was in home directory.  Go figure.
   PATH=$PATH:$HOME

   mkdir -p data/taxonomy
   # Get list of vid's
   drush sqlq 'select vid, name from vocabulary;' | sed 1d | sort -n > data/taxonomy/vocabularies.txt

   for vid in `awk '{print $1}' < data/taxonomy/vocabularies.txt`
   do
       vname=`awk -F'\t' '$1 == "'$vid'" {print $2}' < data/taxonomy/vocabularies.txt`
       drush taxocsv-export $vid def_links --order=tid --enclosure="#" data/taxonomy/$vid.csv
   done
}

# Deprecated... use taxgen and normal migration instead
do_taxin() {
   if ! test -f data/taxonomy/vocabularies.txt
   then
       echo "data/taxonomy/vocabularies.txt not found"
       echo "Did you run $0 taxout on the remote system, and transfer the resulting data directory?"
       exit 1
   fi
   for vid in `awk '{print $1}' < data/taxonomy/vocabularies.txt`
   do
       name=`awk '$1 == "'$vid'" {$1=""; print $0}' < data/taxonomy/vocabularies.txt`
       echo "Got vid $vid, name $name"
       drush taxocsv-import data/taxonomy/$vid.csv def_links --encosure="#" --keep_order --vocabulary_id="$name"
   done
}

usage() {
    cat <<_EOF_
Usage: $0 deps|install|reinstall|taxgen
_EOF_
}

case $1 in
deps) do_deps;;
install) do_install;;
reinstall) do_reinstall;;
taxgen) do_taxgen;;
taxout) do_taxout;;
taxin) do_taxin;;
*) usage; exit 1;;
esac
